// KV 바인딩: env.COMMENTS
// 운영자 비번: env.OWNER_PASSWORD
// 보안용: env.SECRET_SALT (선택)

async function sha256(s) {
  const buf = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(s));
  return [...new Uint8Array(buf)].map(b => b.toString(16).padStart(2,"0")).join("");
}
async function ipHash(req, env) {
  const ip =
    req.headers.get("cf-connecting-ip") ||
    req.headers.get("CF-Connecting-IP") ||
    "0.0.0.0";
  return await sha256(ip + (env.SECRET_SALT || "salt"));
}
function json(data, init = 200) {
  return new Response(JSON.stringify(data), {
    status: typeof init === "number" ? init : (init.status || 200),
    headers: { "Content-Type": "application/json" }
  });
}

// --- GET /api/comments : 목록 조회
export async function onRequestGet({ env }) {
  const idxRaw = await env.COMMENTS.get("idx");
  if (!idxRaw) return json([]);
  const idx = JSON.parse(idxRaw);
  const out = [];
  for (const id of idx) {
    const c = await env.COMMENTS.get("comments:" + id);
    if (c) out.push(JSON.parse(c));
  }
  return json(out);
}

// --- POST /api/comments : 코멘트 작성 (1인 1회)
export async function onRequestPost({ request, env }) {
  const body = await request.json().catch(() => ({}));
  const text = (body.text || "").trim();
  if (!text) return json({ error: "내용이 비어있습니다." }, 400);

  // 1회 제한 (IP 해시 기준)
  const ip = await ipHash(request, env);
  const prev = await env.COMMENTS.get("by:" + ip);
  if (prev) return json({ error: "이미 코멘트를 작성했습니다." }, 403);

  // 신규 ID
  let idxRaw = await env.COMMENTS.get("idx");
  let idx = idxRaw ? JSON.parse(idxRaw) : [];
  const newId = idx.length + 1;
  const entry = {
    id: newId,
    text,
    by: "탈출자 " + newId,
    at: Date.now()
  };

  // 저장
  idx.push(newId);
  await env.COMMENTS.put("idx", JSON.stringify(idx));
  await env.COMMENTS.put("comments:" + newId, JSON.stringify(entry));
  await env.COMMENTS.put("by:" + ip, String(newId));

  return json(entry);
}

// --- DELETE /api/comments : 운영자만 삭제 (번호 당겨짐)
export async function onRequestDelete({ request, env }) {
  const auth = request.headers.get("Authorization") || "";
  if (auth !== "Bearer " + env.OWNER_PASSWORD) {
    return new Response("권한 없음", { status: 403 });
  }
  const { id } = await request.json().catch(() => ({}));
  if (!id) return new Response("잘못된 요청", { status: 400 });

  // 기존 인덱스 로드
  let idxRaw = await env.COMMENTS.get("idx");
  let idx = idxRaw ? JSON.parse(idxRaw) : [];

  // 대상 제거
  idx = idx.filter(x => x !== id);

  // 코멘트 재번호 부여(1부터)
  const newList = [];
  for (let i = 0; i < idx.length; i++) {
    const oldId = idx[i];
    const saved = await env.COMMENTS.get("comments:" + oldId);
    if (!saved) continue;
    const parsed = JSON.parse(saved);
    parsed.id = i + 1;
    parsed.by = "탈출자 " + (i + 1);
    newList.push(parsed);
  }

  // 전체 초기화 후 재저장
  // (기존 키를 일일이 지우는 대신 덮어쓰기 + idx 재작성)
  await env.COMMENTS.put("idx", JSON.stringify(newList.map(c => c.id)));
  for (const c of newList) {
    await env.COMMENTS.put("comments:" + c.id, JSON.stringify(c));
  }

  return json({ ok: true });
}

// --- OPTIONS (CORS/프리플라이트 대비)
export async function onRequestOptions() {
  return new Response(null, {
    status: 204,
    headers: {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "GET, POST, DELETE, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, Authorization"
    }
  });
}
